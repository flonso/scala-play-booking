package controllers

import forms.BookingForms
import javax.inject._
import models._
import org.joda.time._
import play.api.i18n.I18nSupport
import play.api.mvc._
import utils.JodaDateUtils
import utils.JodaDateUtils.dateOrdering

import scala.collection.immutable.ListMap

@Singleton
class BookingController @Inject()(cc: ControllerComponents)(implicit assetsFinder: AssetsFinder)
    extends AbstractController(cc)
    with I18nSupport {

  /**
    * Displays the form allowing to chose an AppointmentType.
    */
  def chooseAppointmentTypeForm = Action { implicit request =>
    Ok(views.html.appointmentTypeForm(BookingForms.chooseAppointmentTypeForm))
  }

  /**
    * Handles form submissions performed through the [[AppointmentType]] choosing form.
    * The corresponding view is [[views.html.appointmentTypeForm]]
    */
  def processAppointmentTypeForm = Action { implicit request =>
    BookingForms.chooseAppointmentTypeForm
      .bindFromRequest()
      .fold(
        formWithErrors => Ok(views.html.appointmentTypeForm(formWithErrors)),
        a =>
          Redirect(
            routes.BookingController
              .chooseTimeSlotForm(a.label, Some(JodaDateUtils.dateToUrlString())))
      )

  }

  /**
    * Builds a list of available timeslots for a given AppointmentType and from a given starting
    * date.
    * @param tpe A String representation of an [[AppointmentType]]
    * @param date A String representation of a starting date, see [[JodaDateUtils.URL_DATE_PATTERN]]
    */
  def chooseTimeSlotForm(tpe: String, date: Option[String]) = Action { implicit request =>
    val parsedDate = JodaDateUtils.parseUrlDate(date)

    val startingDate = if (parsedDate.isBeforeNow) DateTime.now else parsedDate

    AppointmentType
      .durationFromType(tpe)
      .fold(
        error => BadRequest(error),
        timeSlotDuration => {
          val schedule = Database.query[Schedule].fetchOne()

          // Build the list of available timeslots
          val timeSlots =
            schedule.fold(Seq.empty[TimeSlot])(_.availableTimeSlots(startingDate, timeSlotDuration))

          //
          val sorted = ListMap(
            timeSlots
              .sortBy(s => s.start)
              .groupBy(_.start.withTime(0, 0, 0, 0))
              .toSeq
              .sortBy(m => m._1): _*
          )

          Ok(views.html.timeSlotForm(sorted, tpe, startingDate, BookingForms.chooseTimeSlotForm))
        }
      )
  }

  /**
    * Processes data submitted through the form generated by chooseTimeSlotForm and validates it.
    * @param tpe A String representation of an [[AppointmentType]]
    * @param date A String representation of a starting date, see [[JodaDateUtils.URL_DATE_PATTERN]]
    */
  def processTimeSlotForm(tpe: String, date: Option[String]) = Action { implicit request =>
    BookingForms.chooseTimeSlotForm
      .bindFromRequest()
      .fold(
        formWithErrors => {
          val d = JodaDateUtils.parseUrlDate(date)
          Ok(views.html.timeSlotForm(ListMap.empty, tpe, d, formWithErrors))
        },
        s => {
          Redirect(
            routes.BookingController.personalInfoForm(tpe, s.start.toString(TimeSlot.URL_PATTERN)))
        }
      )

  }

  /**
    * Display a simple form inviting the user to fill personal informations.
    * @param tpe A String representation of an [[AppointmentType]]
    * @param timeSlot A String representation of a [[TimeSlot]], see [[TimeSlot.URL_PATTERN]]
    */
  def personalInfoForm(tpe: String, timeSlot: String) = Action { implicit request =>
    Ok(views.html.personalInfoForm(tpe, timeSlot, BookingForms.personalInfoForm))
  }

  def performBooking(tpe: String, timeSlot: String) = Action { implicit request =>
    BookingForms.personalInfoForm
      .bindFromRequest()
      .fold(
        formWithErrors => {
          Ok(views.html.personalInfoForm(tpe, timeSlot, formWithErrors))
        },
        a => {
          val persistedTimeSlot = Database.save(a.timeSlot)
          val persistedPatient = Database.save(a.patient)

          val persistedAppointment =
            Database.save(a.copy(timeSlot = persistedTimeSlot, patient = persistedPatient))

          Redirect(routes.BookingController.displayConfirmation(persistedAppointment.id))
        }
      )
  }

  /**
    * Displays a simple confirmation page containing a summary of the freshly booked [[Appointment]].
    * @param id A Long value representing the [[Appointment]] in the database
    */
  def displayConfirmation(id: Long) = Action {
    Database
      .query[Appointment]
      .whereEqual("id", id)
      .fetchOne()
      .fold(NotFound(s"Could not find appointment with id $id")) { a =>
        Ok(views.html.bookingConfirmation(a))
      }

  }

  /**
    * Displays all booked [[Appointment]] to the user.
    */
  def listAppointments = Action {
    val appointments = Database.query[Appointment].fetch().sortBy(_.timeSlot.start)

    Ok(views.html.listAppointments(appointments))
  }
}
